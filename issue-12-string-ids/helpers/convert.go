// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package helpers

import (
"context"
"fmt"
"io"
"strconv"
"time"
"sync"
"errors"
"bytes"
"strings"
"github.com/web-ridge/utils-go/boilergql"
gqlparser "github.com/vektah/gqlparser/v2"
"github.com/vektah/gqlparser/v2/ast"
"github.com/99designs/gqlgen/graphql"
"github.com/99designs/gqlgen/graphql/introspection"
"github.com/ericlagergren/decimal"
"github.com/volatiletech/sqlboiler/v4/boil"
"github.com/volatiletech/sqlboiler/v4/queries"
"github.com/volatiletech/sqlboiler/v4/queries/qm"
"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
"github.com/volatiletech/sqlboiler/v4/types"
null "github.com/volatiletech/null/v8"
"database/sql"
"github.com/web-ridge/gqlgen-sqlboiler-examples/issue-12-string-ids/models"
"github.com/web-ridge/gqlgen-sqlboiler-examples/issue-12-string-ids/graphql_models")
































	func CommentWithUintID(id uint) *graphql_models.Comment {
			return &graphql_models.Comment{
				ID: CommentIDToGraphQL(id),
			}
		}

		func CommentWithIntID(id int) *graphql_models.Comment {
			return CommentWithUintID(uint(id))
		}

		func CommentWithNullDotUintID(id null.Uint) *graphql_models.Comment {
			return CommentWithUintID(id.Uint)
		}

		func CommentWithNullDotIntID(id null.Int) *graphql_models.Comment {
			return CommentWithUintID(uint(id.Int))
		}

		func CommentsToGraphQL(am []*models.Comment)( []*graphql_models.Comment) {
			ar := make([]*graphql_models.Comment, len(am))
			for i,m := range am {
				ar[i] = CommentToGraphQL(m)
			}
			return ar
		}
	
		func CommentIDToGraphQL(v uint) string {
					return boilergql.IDToGraphQL(v, models.TableNames.Comment)
				}


	func CommentToGraphQL(m *models.Comment)( *graphql_models.Comment) {
		if m == nil {
			return nil
		}

		r := &graphql_models.Comment{
			ID: ,	
					Content: m.Content,
		}

			
				
				if boilergql.NullDotStringIsFilled(m.PostID) {
					if m.R != nil && m.R.Post != nil  {
						r.Post = PostToGraphQL(m.R.Post)
					} else {
						r.Post = PostWithNullDotStringID(m.PostID)
					}
				}	
				
				if boilergql.StringIsFilled(m.UserID) {
					if m.R != nil && m.R.User != nil  {
						r.User = UserToGraphQL(m.R.User)
					} else {
						r.User = UserWithStringID(m.UserID)
					}
				}
					if m.R != nil && m.R.CommentLikes != nil  {
						r.CommentLikes = CommentLikesToGraphQL(m.R.CommentLikes)
					}

		return r
	}

		
				func CommentID(v string) string {
					return boilergql.IDToBoilerString(v)
				}

				func CommentIDs(a []string) []string {
					return boilergql.IDsToBoilerString(a)
				}
	
	
	
	func CommentLikeWithUintID(id uint) *graphql_models.CommentLike {
			return &graphql_models.CommentLike{
				ID: CommentLikeIDToGraphQL(id),
			}
		}

		func CommentLikeWithIntID(id int) *graphql_models.CommentLike {
			return CommentLikeWithUintID(uint(id))
		}

		func CommentLikeWithNullDotUintID(id null.Uint) *graphql_models.CommentLike {
			return CommentLikeWithUintID(id.Uint)
		}

		func CommentLikeWithNullDotIntID(id null.Int) *graphql_models.CommentLike {
			return CommentLikeWithUintID(uint(id.Int))
		}

		func CommentLikesToGraphQL(am []*models.CommentLike)( []*graphql_models.CommentLike) {
			ar := make([]*graphql_models.CommentLike, len(am))
			for i,m := range am {
				ar[i] = CommentLikeToGraphQL(m)
			}
			return ar
		}
	
		func CommentLikeIDToGraphQL(v uint) string {
					return boilergql.IDToGraphQL(v, models.TableNames.CommentLike)
				}


	func CommentLikeToGraphQL(m *models.CommentLike)( *graphql_models.CommentLike) {
		if m == nil {
			return nil
		}

		r := &graphql_models.CommentLike{
			ID: ,	
					LikeType: m.LikeType,
					CreatedAt: boilergql.NullDotTimeToPointerInt(m.CreatedAt),
		}

			
				
				if boilergql.StringIsFilled(m.CommentID) {
					if m.R != nil && m.R.Comment != nil  {
						r.Comment = CommentToGraphQL(m.R.Comment)
					} else {
						r.Comment = CommentWithStringID(m.CommentID)
					}
				}	
				
				if boilergql.StringIsFilled(m.UserID) {
					if m.R != nil && m.R.User != nil  {
						r.User = UserToGraphQL(m.R.User)
					} else {
						r.User = UserWithStringID(m.UserID)
					}
				}

		return r
	}

		
				func CommentLikeID(v string) string {
					return boilergql.IDToBoilerString(v)
				}

				func CommentLikeIDs(a []string) []string {
					return boilergql.IDsToBoilerString(a)
				}
	
	
	
	
	
	
	
	
	
	func FriendshipWithUintID(id uint) *graphql_models.Friendship {
			return &graphql_models.Friendship{
				ID: FriendshipIDToGraphQL(id),
			}
		}

		func FriendshipWithIntID(id int) *graphql_models.Friendship {
			return FriendshipWithUintID(uint(id))
		}

		func FriendshipWithNullDotUintID(id null.Uint) *graphql_models.Friendship {
			return FriendshipWithUintID(id.Uint)
		}

		func FriendshipWithNullDotIntID(id null.Int) *graphql_models.Friendship {
			return FriendshipWithUintID(uint(id.Int))
		}

		func FriendshipsToGraphQL(am []*models.Friendship)( []*graphql_models.Friendship) {
			ar := make([]*graphql_models.Friendship, len(am))
			for i,m := range am {
				ar[i] = FriendshipToGraphQL(m)
			}
			return ar
		}
	
		func FriendshipIDToGraphQL(v uint) string {
					return boilergql.IDToGraphQL(v, models.TableNames.Friendship)
				}


	func FriendshipToGraphQL(m *models.Friendship)( *graphql_models.Friendship) {
		if m == nil {
			return nil
		}

		r := &graphql_models.Friendship{
			ID: ,
					CreatedAt: boilergql.NullDotTimeToPointerInt(m.CreatedAt),
		}

		
					if m.R != nil && m.R.Users != nil  {
						r.Users = UsersToGraphQL(m.R.Users)
					}

		return r
	}

		
				func FriendshipID(v string) string {
					return boilergql.IDToBoilerString(v)
				}

				func FriendshipIDs(a []string) []string {
					return boilergql.IDsToBoilerString(a)
				}
	
	
	
	
	
	
	func ImageWithUintID(id uint) *graphql_models.Image {
			return &graphql_models.Image{
				ID: ImageIDToGraphQL(id),
			}
		}

		func ImageWithIntID(id int) *graphql_models.Image {
			return ImageWithUintID(uint(id))
		}

		func ImageWithNullDotUintID(id null.Uint) *graphql_models.Image {
			return ImageWithUintID(id.Uint)
		}

		func ImageWithNullDotIntID(id null.Int) *graphql_models.Image {
			return ImageWithUintID(uint(id.Int))
		}

		func ImagesToGraphQL(am []*models.Image)( []*graphql_models.Image) {
			ar := make([]*graphql_models.Image, len(am))
			for i,m := range am {
				ar[i] = ImageToGraphQL(m)
			}
			return ar
		}
	
		func ImageIDToGraphQL(v uint) string {
					return boilergql.IDToGraphQL(v, models.TableNames.Image)
				}


	func ImageToGraphQL(m *models.Image)( *graphql_models.Image) {
		if m == nil {
			return nil
		}

		r := &graphql_models.Image{
			ID: ,
					Views: boilergql.NullDotIntToPointerInt(m.Views),
					OriginalURL: boilergql.NullDotStringToPointerString(m.OriginalURL),
		}

			
				
				if boilergql.StringIsFilled(m.PostID) {
					if m.R != nil && m.R.Post != nil  {
						r.Post = PostToGraphQL(m.R.Post)
					} else {
						r.Post = PostWithStringID(m.PostID)
					}
				}
					if m.R != nil && m.R.ImageVariations != nil  {
						r.ImageVariations = ImageVariationsToGraphQL(m.R.ImageVariations)
					}

		return r
	}

		
				func ImageID(v string) string {
					return boilergql.IDToBoilerString(v)
				}

				func ImageIDs(a []string) []string {
					return boilergql.IDsToBoilerString(a)
				}
	
	
	
	
	
	func ImageVariationWithUintID(id uint) *graphql_models.ImageVariation {
			return &graphql_models.ImageVariation{
				ID: ImageVariationIDToGraphQL(id),
			}
		}

		func ImageVariationWithIntID(id int) *graphql_models.ImageVariation {
			return ImageVariationWithUintID(uint(id))
		}

		func ImageVariationWithNullDotUintID(id null.Uint) *graphql_models.ImageVariation {
			return ImageVariationWithUintID(id.Uint)
		}

		func ImageVariationWithNullDotIntID(id null.Int) *graphql_models.ImageVariation {
			return ImageVariationWithUintID(uint(id.Int))
		}

		func ImageVariationsToGraphQL(am []*models.ImageVariation)( []*graphql_models.ImageVariation) {
			ar := make([]*graphql_models.ImageVariation, len(am))
			for i,m := range am {
				ar[i] = ImageVariationToGraphQL(m)
			}
			return ar
		}
	
		func ImageVariationIDToGraphQL(v uint) string {
					return boilergql.IDToGraphQL(v, models.TableNames.ImageVariation)
				}


	func ImageVariationToGraphQL(m *models.ImageVariation)( *graphql_models.ImageVariation) {
		if m == nil {
			return nil
		}

		r := &graphql_models.ImageVariation{
			ID: ,
		}

			
				
				if boilergql.StringIsFilled(m.ImageID) {
					if m.R != nil && m.R.Image != nil  {
						r.Image = ImageToGraphQL(m.R.Image)
					} else {
						r.Image = ImageWithStringID(m.ImageID)
					}
				}

		return r
	}

		
				func ImageVariationID(v string) string {
					return boilergql.IDToBoilerString(v)
				}

				func ImageVariationIDs(a []string) []string {
					return boilergql.IDsToBoilerString(a)
				}
	
	
	
	
	
	
	
	func LikeWithUintID(id uint) *graphql_models.Like {
			return &graphql_models.Like{
				ID: LikeIDToGraphQL(id),
			}
		}

		func LikeWithIntID(id int) *graphql_models.Like {
			return LikeWithUintID(uint(id))
		}

		func LikeWithNullDotUintID(id null.Uint) *graphql_models.Like {
			return LikeWithUintID(id.Uint)
		}

		func LikeWithNullDotIntID(id null.Int) *graphql_models.Like {
			return LikeWithUintID(uint(id.Int))
		}

		func LikesToGraphQL(am []*models.Like)( []*graphql_models.Like) {
			ar := make([]*graphql_models.Like, len(am))
			for i,m := range am {
				ar[i] = LikeToGraphQL(m)
			}
			return ar
		}
	
		func LikeIDToGraphQL(v uint) string {
					return boilergql.IDToGraphQL(v, models.TableNames.Like)
				}


	func LikeToGraphQL(m *models.Like)( *graphql_models.Like) {
		if m == nil {
			return nil
		}

		r := &graphql_models.Like{
			ID: ,	
					LikeType: m.LikeType,
					CreatedAt: boilergql.NullDotTimeToPointerInt(m.CreatedAt),
		}

			
				
				if boilergql.StringIsFilled(m.PostID) {
					if m.R != nil && m.R.Post != nil  {
						r.Post = PostToGraphQL(m.R.Post)
					} else {
						r.Post = PostWithStringID(m.PostID)
					}
				}	
				
				if boilergql.StringIsFilled(m.UserID) {
					if m.R != nil && m.R.User != nil  {
						r.User = UserToGraphQL(m.R.User)
					} else {
						r.User = UserWithStringID(m.UserID)
					}
				}

		return r
	}

		
				func LikeID(v string) string {
					return boilergql.IDToBoilerString(v)
				}

				func LikeIDs(a []string) []string {
					return boilergql.IDsToBoilerString(a)
				}
	
	
	
	
	
	
	func PostWithUintID(id uint) *graphql_models.Post {
			return &graphql_models.Post{
				ID: PostIDToGraphQL(id),
			}
		}

		func PostWithIntID(id int) *graphql_models.Post {
			return PostWithUintID(uint(id))
		}

		func PostWithNullDotUintID(id null.Uint) *graphql_models.Post {
			return PostWithUintID(id.Uint)
		}

		func PostWithNullDotIntID(id null.Int) *graphql_models.Post {
			return PostWithUintID(uint(id.Int))
		}

		func PostsToGraphQL(am []*models.Post)( []*graphql_models.Post) {
			ar := make([]*graphql_models.Post, len(am))
			for i,m := range am {
				ar[i] = PostToGraphQL(m)
			}
			return ar
		}
	
		func PostIDToGraphQL(v uint) string {
					return boilergql.IDToGraphQL(v, models.TableNames.Post)
				}


	func PostToGraphQL(m *models.Post)( *graphql_models.Post) {
		if m == nil {
			return nil
		}

		r := &graphql_models.Post{
			ID: ,	
					Content: m.Content,
		}

			
				
				if boilergql.StringIsFilled(m.UserID) {
					if m.R != nil && m.R.User != nil  {
						r.User = UserToGraphQL(m.R.User)
					} else {
						r.User = UserWithStringID(m.UserID)
					}
				}
					if m.R != nil && m.R.Comments != nil  {
						r.Comments = CommentsToGraphQL(m.R.Comments)
					}
					if m.R != nil && m.R.Images != nil  {
						r.Images = ImagesToGraphQL(m.R.Images)
					}
					if m.R != nil && m.R.Likes != nil  {
						r.Likes = LikesToGraphQL(m.R.Likes)
					}

		return r
	}

		
				func PostID(v string) string {
					return boilergql.IDToBoilerString(v)
				}

				func PostIDs(a []string) []string {
					return boilergql.IDsToBoilerString(a)
				}
	
	
	
	
	
	
	func UserWithUintID(id uint) *graphql_models.User {
			return &graphql_models.User{
				ID: UserIDToGraphQL(id),
			}
		}

		func UserWithIntID(id int) *graphql_models.User {
			return UserWithUintID(uint(id))
		}

		func UserWithNullDotUintID(id null.Uint) *graphql_models.User {
			return UserWithUintID(id.Uint)
		}

		func UserWithNullDotIntID(id null.Int) *graphql_models.User {
			return UserWithUintID(uint(id.Int))
		}

		func UsersToGraphQL(am []*models.User)( []*graphql_models.User) {
			ar := make([]*graphql_models.User, len(am))
			for i,m := range am {
				ar[i] = UserToGraphQL(m)
			}
			return ar
		}
	
		func UserIDToGraphQL(v uint) string {
					return boilergql.IDToGraphQL(v, models.TableNames.User)
				}


	func UserToGraphQL(m *models.User)( *graphql_models.User) {
		if m == nil {
			return nil
		}

		r := &graphql_models.User{
			ID: ,	
					FirstName: m.FirstName,	
					LastName: m.LastName,	
					Email: m.Email,
		}

		
					if m.R != nil && m.R.Comments != nil  {
						r.Comments = CommentsToGraphQL(m.R.Comments)
					}
					if m.R != nil && m.R.CommentLikes != nil  {
						r.CommentLikes = CommentLikesToGraphQL(m.R.CommentLikes)
					}
					if m.R != nil && m.R.Likes != nil  {
						r.Likes = LikesToGraphQL(m.R.Likes)
					}
					if m.R != nil && m.R.Posts != nil  {
						r.Posts = PostsToGraphQL(m.R.Posts)
					}
					if m.R != nil && m.R.Friendships != nil  {
						r.Friendships = FriendshipsToGraphQL(m.R.Friendships)
					}

		return r
	}

		
				func UserID(v string) string {
					return boilergql.IDToBoilerString(v)
				}

				func UserIDs(a []string) []string {
					return boilergql.IDsToBoilerString(a)
				}
	
	
	
	
	
	
